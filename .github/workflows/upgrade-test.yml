name: Kubernetes Cluster Upgrade Tests

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      start_version:
        description: 'Starting Kubernetes version (e.g., 1.33)'
        required: false
        type: string
        default: '1.33'
      os_image:
        description: 'OS image to test'
        required: false
        type: choice
        options:
          - ubuntu-24.04
          - ubuntu-25.10
          - centos9
          - centos10
        default: 'ubuntu-24.04'

env:
  WORKING_DIR: ci-cd/test

jobs:
  test-upgrade:
    name: Upgrade Test ${{ matrix.start_version }} → 1.35 on ${{ matrix.os_image }}
    runs-on:
      group: Default
    timeout-minutes: 120
    # env:
      # PIPX_HOME: /opt/pipx
      # PIPX_BIN_DIR: /usr/local/bin
    strategy:
      fail-fast: false
      max-parallel: 5
      matrix:
        start_version:
          - "1.33"
          - "1.34"
        os_image:
          - ubuntu-24.04
          - centos9

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up PATH
        run: echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Install dependencies
        run: |
          # Update package list
          sudo apt-get update

          # Install pipx for Ansible installation
          sudo apt-get install -y pipx python3-pip python3-venv

          # Install Ansible using pipx
          pipx install --include-deps ansible
          pipx ensurepath

          # Inject dnspython into Ansible virtual environment
          pipx inject ansible dnspython

          # Install Ansible collections from requirements.yaml
          ansible-galaxy collection install -r requirements.yaml

          # Install OpenTofu
          if ! command -v tofu &> /dev/null; then
            echo "Installing OpenTofu..."
            curl --proto '=https' --tlsv1.2 -fsSL https://get.opentofu.org/install-opentofu.sh > /tmp/install-opentofu.sh
            sudo bash /tmp/install-opentofu.sh --install-method deb
          fi

          # Install kubectl
          if ! command -v kubectl &> /dev/null; then
            echo "Installing kubectl..."
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
            rm kubectl
          fi

          # Install jq for JSON parsing
          sudo apt-get install -y jq

          # Verify installations
          echo "Verifying installations..."
          ansible --version
          tofu --version
          kubectl version --client
          jq --version

      - name: Spin up test environment
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          ./spin-up-test-environment.sh --os-image ${{ matrix.os_image }}
        env:
          GITHUB_RUN_NUMBER: ${{ github.run_number }}

      - name: Install initial Kubernetes version
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          echo "Installing Kubernetes ${{ matrix.start_version }}"
          ./install.sh -v ${{ matrix.start_version }}

      - name: Verify initial cluster
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          cd tofu
          TOFU_OUTPUT=$(tofu output -json)
          CP1_HOST=$(echo "${TOFU_OUTPUT}" | jq -r '.information.value.control_planes[0].hostname')

          ssh ubuntu@${CP1_HOST} "sudo cat /etc/kubernetes/admin.conf" > /tmp/kubeconfig-${{ github.run_number }}
          export KUBECONFIG=/tmp/kubeconfig-${{ github.run_number }}

          kubectl wait --for=condition=Ready nodes --all --timeout=600s

          # Deploy a test workload to verify it persists through upgrades
          kubectl create namespace upgrade-test || true
          kubectl create deployment nginx-upgrade-test --image=quay.io/prometheus/busybox:latest --replicas=3 -n upgrade-test -- sh -c "while true; do sleep 3600; done"
          kubectl rollout status deployment/nginx-upgrade-test -n upgrade-test --timeout=300s

          echo "Initial cluster version:"
          kubectl version --short
          kubectl get nodes -o wide

      - name: Upgrade to 1.34 (if starting from 1.33)
        if: matrix.start_version == '1.33'
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          echo "Upgrading to Kubernetes 1.34..."
          ./upgrade.sh -v 1.34

          # Verify upgrade
          export KUBECONFIG=/tmp/kubeconfig-${{ github.run_number }}

          # Wait for nodes to be ready after upgrade
          kubectl wait --for=condition=Ready nodes --all --timeout=600s

          # Verify test workload is still running
          kubectl rollout status deployment/nginx-upgrade-test -n upgrade-test --timeout=300s

          echo "Cluster after 1.34 upgrade:"
          kubectl version --short
          kubectl get nodes -o wide

      - name: Upgrade to 1.35
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          echo "Upgrading to Kubernetes 1.35..."
          ./upgrade.sh -v 1.35

          # Verify final upgrade
          export KUBECONFIG=/tmp/kubeconfig-${{ github.run_number }}

          kubectl wait --for=condition=Ready nodes --all --timeout=600s

          # Verify test workload is still running
          kubectl rollout status deployment/nginx-upgrade-test -n upgrade-test --timeout=300s

          echo "Cluster after 1.35 upgrade:"
          kubectl version --short
          kubectl get nodes -o wide

      - name: Verify final cluster state
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          export KUBECONFIG=/tmp/kubeconfig-${{ github.run_number }}

          # Verify all nodes are running Kubernetes 1.35
          echo "Verifying all nodes are on version 1.35..."
          kubectl get nodes -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.nodeInfo.kubeletVersion}{"\n"}{end}'

          # Check if any node is not on 1.35
          NON_135_NODES=$(kubectl get nodes -o json | jq -r '.items[] | select(.status.nodeInfo.kubeletVersion | startswith("v1.35") | not) | .metadata.name')
          if [ -n "${NON_135_NODES}" ]; then
            echo "ERROR: The following nodes are not on version 1.35:"
            echo "${NON_135_NODES}"
            exit 1
          fi

          # Verify test workload is healthy
          READY_REPLICAS=$(kubectl get deployment nginx-upgrade-test -n upgrade-test -o jsonpath='{.status.readyReplicas}')
          if [ "${READY_REPLICAS}" != "3" ]; then
            echo "ERROR: Expected 3 ready replicas, found ${READY_REPLICAS}"
            kubectl describe deployment nginx-upgrade-test -n upgrade-test
            exit 1
          fi

          # Check for any pods in error state
          ERROR_PODS=$(kubectl get pods -A --field-selector=status.phase!=Running,status.phase!=Succeeded --no-headers 2>/dev/null | wc -l)
          if [ "${ERROR_PODS}" -gt 0 ]; then
            echo "WARNING: Found ${ERROR_PODS} pods not in Running/Succeeded state"
            kubectl get pods -A --field-selector=status.phase!=Running,status.phase!=Succeeded
          fi

          echo "Upgrade verification complete!"
          echo "Successfully upgraded from ${{ matrix.start_version }} to 1.35"

      - name: Run post-upgrade smoke tests
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          export KUBECONFIG=/tmp/kubeconfig-${{ github.run_number }}

          # Create a new deployment to test cluster functionality
          kubectl create deployment post-upgrade-test --image=quay.io/prometheus/busybox:latest --replicas=2 -n upgrade-test -- sh -c "while true; do sleep 3600; done"
          kubectl rollout status deployment/post-upgrade-test -n upgrade-test --timeout=300s

          # Verify deployment
          READY_REPLICAS=$(kubectl get deployment post-upgrade-test -n upgrade-test -o jsonpath='{.status.readyReplicas}')
          if [ "${READY_REPLICAS}" != "2" ]; then
            echo "ERROR: Expected 2 ready replicas, found ${READY_REPLICAS}"
            exit 1
          fi

          # Clean up test namespace
          kubectl delete namespace upgrade-test --timeout=120s

          echo "Post-upgrade smoke tests passed!"

      - name: Collect logs on failure
        if: failure()
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          mkdir -p /tmp/upgrade-logs-${{ github.run_number }}

          cd tofu
          TOFU_OUTPUT=$(tofu output -json) || true
          echo "${TOFU_OUTPUT}" > /tmp/upgrade-logs-${{ github.run_number }}/tofu-output.json 2>&1 || true

          if [ -n "${TOFU_OUTPUT}" ]; then
            ALL_HOSTS=$(echo "${TOFU_OUTPUT}" | jq -r '.information.value | (.proxy.hostname, .control_planes[].hostname, .workers[].hostname)' 2>/dev/null)

            for host in ${ALL_HOSTS}; do
              echo "Collecting logs from ${host}..."
              ssh ansible@${host} -i "~/.ssh/gh-${GITHUB_RUN_NUMBER:--vm}.pem" "sudo journalctl -u kubelet -n 1000" > /tmp/upgrade-logs-${{ github.run_number }}/${host}-kubelet.log 2>&1 || true
              ssh ansible@${host} -i "~/.ssh/gh-${GITHUB_RUN_NUMBER:--vm}.pem" "sudo journalctl -u containerd -n 500" > /tmp/upgrade-logs-${{ github.run_number }}/${host}-containerd.log 2>&1 || true
              ssh ansible@${host} -i "~/.ssh/gh-${GITHUB_RUN_NUMBER:--vm}.pem" "sudo kubeadm version" > /tmp/upgrade-logs-${{ github.run_number }}/${host}-kubeadm-version.log 2>&1 || true
            done
          fi

          if [ -f "/tmp/kubeconfig-${{ github.run_number }}" ]; then
            export KUBECONFIG=/tmp/kubeconfig-${{ github.run_number }}
            kubectl get all -A > /tmp/upgrade-logs-${{ github.run_number }}/kubectl-get-all.log 2>&1 || true
            kubectl get nodes -o wide > /tmp/upgrade-logs-${{ github.run_number }}/kubectl-nodes.log 2>&1 || true
            kubectl get events -A --sort-by='.lastTimestamp' > /tmp/upgrade-logs-${{ github.run_number }}/kubectl-events.log 2>&1 || true
            kubectl version --output=yaml > /tmp/upgrade-logs-${{ github.run_number }}/kubectl-version.log 2>&1 || true
          fi

      - name: Upload logs artifact
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: upgrade-logs-${{ matrix.start_version }}-to-1.35-${{ matrix.os_image }}-${{ github.run_number }}
          path: /tmp/upgrade-logs-${{ github.run_number }}/
          retention-days: 7

      - name: Cleanup test environment
        if: always()
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          ./shutdown-test-environment.sh || true
          rm -f /tmp/kubeconfig-${{ github.run_number }} || true
          rm -rf /tmp/upgrade-logs-${{ github.run_number }} || true

  # Test direct upgrade from 1.33 to 1.35 (skipping 1.34)
  test-skip-version-upgrade:
    name: Skip Version Upgrade Test (1.33 → 1.35)
    runs-on:
      group: Default
    timeout-minutes: 120

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up PATH
        run: echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Install dependencies
        run: |
          # Update package list
          sudo apt-get update

          # Install pipx for Ansible installation
          sudo apt-get install -y pipx python3-pip python3-venv

          # Install Ansible using pipx
          pipx install --include-deps ansible
          pipx ensurepath

          # Inject dnspython into Ansible virtual environment
          pipx inject ansible dnspython

          # Install Ansible collections from requirements.yaml
          ansible-galaxy collection install -r requirements.yaml

          # Install OpenTofu
          if ! command -v tofu &> /dev/null; then
            echo "Installing OpenTofu..."
            curl --proto '=https' --tlsv1.2 -fsSL https://get.opentofu.org/install-opentofu.sh > /tmp/install-opentofu.sh
            sudo bash /tmp/install-opentofu.sh --install-method deb
          fi

          # Install kubectl
          if ! command -v kubectl &> /dev/null; then
            echo "Installing kubectl..."
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
            rm kubectl
          fi

          # Install jq for JSON parsing
          sudo apt-get install -y jq

          # Verify installations
          echo "Verifying installations..."
          ansible --version
          tofu --version
          kubectl version --client
          jq --version

      - name: Spin up test environment
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          ./spin-up-test-environment.sh --os-image ubuntu-24.04
        env:
          GITHUB_RUN_NUMBER: ${{ github.run_number }}

      - name: Install Kubernetes 1.33
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          echo "Installing Kubernetes 1.33"
          ./install.sh -v 1.33

      - name: Verify initial cluster
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          cd tofu
          kubectl wait --for=condition=Ready nodes --all --timeout=600s
          kubectl create deployment skip-version-test --image=quay.io/prometheus/busybox:latest --replicas=2 -- sh -c "while true; do sleep 3600; done"
          kubectl rollout status deployment/skip-version-test --timeout=300s

      - name: Attempt direct upgrade to 1.35
        working-directory: ${{ env.WORKING_DIR }}
        continue-on-error: true
        run: |
          echo "Attempting to upgrade directly from 1.33 to 1.35 (may fail - this is expected)"
          ./upgrade.sh -v 1.35 || {
            echo "Direct upgrade from 1.33 to 1.35 failed as expected"
            echo "Kubernetes upgrade policy typically requires upgrading through intermediate versions"
            exit 0
          }

          echo "Direct upgrade was allowed this should not have happened"
          exit 1

      - name: Cleanup test environment
        if: always()
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          ./shutdown-test-environment.sh || true
          rm -f /tmp/kubeconfig-skip-${{ github.run_number }} || true

  upgrade-summary:
    name: Upgrade Test Summary
    runs-on: ubuntu-latest
    needs: [test-upgrade, test-skip-version-upgrade]
    if: always()
    steps:
      - name: Check upgrade test results
        run: |
          SEQUENTIAL_RESULT="${{ needs.test-upgrade.result }}"
          SKIP_RESULT="${{ needs.test-skip-version-upgrade.result }}"

          echo "Sequential upgrade tests: ${SEQUENTIAL_RESULT}"
          echo "Skip version upgrade test: ${SKIP_RESULT}"

          if [ "${SEQUENTIAL_RESULT}" != "success" ]; then
            echo "::error::Sequential upgrade tests failed. Check the test-upgrade job for details."
            exit 1
          fi

          # Skip version test is allowed to fail
          if [ "${SKIP_RESULT}" == "success" ]; then
            echo "All upgrade tests passed successfully!"
          else
            echo "Sequential upgrade tests passed. Skip version test status: ${SKIP_RESULT}"
          fi
